<!DOCTYPE html>
<html lang="it" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ranking Allenamenti Bike - FIC Canottaggio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        /* Configurazioni di base per il tema scuro */
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #020617; /* Scurisco lo sfondo a Slate-950 per pi√π contrasto */
            color: #E2E8F0; 
            -webkit-font-smoothing: antialiased; 
            -moz-osx-font-smoothing: grayscale; 
            overflow-x: hidden; /* Prevenire scroll orizzontale */
        }
        /* Style per lo sfondo con effetto sfocato */
        .background-gradient { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            filter: blur(150px); /* Aumento il blur per un effetto pi√π soft */
            opacity: 0.4; /* Diminuisco l'opacit√† */
            z-index: -1; 
        }
        .gradient-1 { 
            width: 600px; /* Aumento la dimensione */
            height: 600px; 
            background: radial-gradient(circle, rgba(37, 99, 235, 0.4), transparent 70%); /* Blu pi√π saturo (Blue-600) */
            animation: pulse 10s infinite alternate; 
        }
        .gradient-2 { 
            width: 500px; 
            height: 500px; 
            background: radial-gradient(circle, rgba(168, 85, 247, 0.3), transparent 70%); /* Viola pi√π chiaro (Violet-500) */
            animation: pulse 12s infinite alternate-reverse; 
            top: 60%; /* Sposto leggermente la seconda sfumatura */
            left: 40%;
        }
        @keyframes pulse { 
            0% { transform: translate(-50%, -50%) scale(0.9) rotate(0deg); } 
            100% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); } /* Rotazione meno aggressiva */
        }
        @keyframes spin { 
            to { transform: rotate(360deg); } 
        }
        .loader { 
            border-top-color: #3B82F6; /* Blu di Tailwind */
            animation: spin 1s linear infinite; 
        }
        /* Stile migliorato per gli input di data, con focus state */
        .date-input { 
            background-color: #1E293B; 
            border: 1px solid #334155; 
            border-radius: 0.5rem; 
            padding: 0.5rem 1rem; 
            color: #E2E8F0; 
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .date-input:focus {
            border-color: #3B82F6;
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3); /* Ring per focus */
        }
        /* Nasconde la freccia standard di tipo number (in alcuni browser) */
        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1); /* Rende l'icona bianca su sfondo scuro in WebKit */
            cursor: pointer;
        }
        .ranking-card {
            background-color: #1E293B; /* Sfondo della card pi√π chiaro per separarlo dal contenitore */
            border: 1px solid #334155;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .ranking-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body class="antialiased">
    <div class="background-gradient gradient-1"></div>
    <div class="background-gradient gradient-2"></div>

    <div id="loader-overlay" class="fixed inset-0 bg-slate-950/90 flex flex-col justify-center items-center z-50 transition-opacity duration-500">
        <div class="loader h-16 w-16 animate-spin rounded-full border-4 border-t-4 border-slate-600"></div>
        <p class="mt-4 text-slate-300 font-medium">Caricamento ranking Bike...</p>
    </div>

    <div class="p-4 md:p-10 max-w-7xl mx-auto relative z-10">
        <h1 class="text-4xl md:text-6xl font-extrabold tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-sky-300 text-center mb-6 pt-4">
            Ranking Allenamenti Bike üö¥‚Äç‚ôÇÔ∏è
        </h1>
        
        <div class="bg-slate-900/80 border border-slate-700/60 rounded-xl shadow-2xl p-6 mb-12 flex flex-wrap justify-center items-center gap-6">
            <div class="flex items-center gap-3">
                <label for="startDate" class="text-slate-300 font-semibold">Dal:</label>
                <input type="date" id="startDate" class="date-input w-40">
            </div>
            <div class="flex items-center gap-3">
                <label for="endDate" class="text-slate-300 font-semibold">Al:</label>
                <input type="date" id="endDate" class="date-input w-40">
            </div>
            <button id="filterBtn" class="bg-blue-600 hover:bg-blue-500 active:bg-blue-700 text-white font-bold py-2 px-6 rounded-xl transition-all duration-300 shadow-lg hover:shadow-blue-500/50">
                Filtra <span class="ml-1">‚Üí</span>
            </button>
        </div>

        <div class="text-center mb-10">
            <a href="home_ranking.html" class="inline-flex items-center bg-slate-800/70 hover:bg-slate-700/70 text-slate-300 font-medium py-2.5 px-6 rounded-xl transition-colors duration-300 border border-slate-700">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                </svg>
                Torna alla Selezione
            </a>
        </div>
        
        <div id="results-container" class="space-y-10"></div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyAQ_0F8KCks_4Wn2h2aTIepQY9VrIkWpUQ", authDomain: "database-atleti-fic.firebaseapp.com",
            databaseURL: "https://database-atleti-fic-default-rtdb.firebaseio.com", projectId: "database-atleti-fic",
            storageBucket: "database-atleti-fic.firebasestorage.app", messagingSenderId: "860422140545",
            appId: "1:860422140545:web:cd14c042a47f2650681380"
        };
        firebase.initializeApp(firebaseConfig);
        const firestore = firebase.firestore();

        const loaderOverlay = document.getElementById('loader-overlay');
        const resultsContainer = document.getElementById('results-container');
        
        // La mappa athleteRecords non √® pi√π necessaria per il calcolo dell'EP,
        // ma la manteniamo per recuperare nome e cognome
        let athleteRecords = new Map(); 

        // Elementi Data
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const filterBtn = document.getElementById('filterBtn');

        // Funzione per ottenere la data odierna in formato YYYY-MM-DD
        function getTodayDateString() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // --- FUNZIONI DI FORMATTAZIONE (Rimosse timeToSeconds e secondsToTimeFormat) ---

        /**
         * Converte una stringa di tempo (min:sec.decimi) in secondi totali.
         * Mantenuta per il calcolo del tempo totale di allenamento se necessario.
         * @param {string} timeStr - Stringa nel formato "mm:ss.d"
         * @returns {number} Secondi totali.
         */
        function timeToSeconds(timeStr) {
            if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) return 0;
            const parts = timeStr.split(':');
            const minutes = parseInt(parts[0], 10);
            // Sostituisce la virgola con il punto per il parsing decimale
            const seconds = parseFloat(parts[1].replace(',', '.')); 
            if (isNaN(minutes) || isNaN(seconds)) return 0;
            return (minutes * 60) + seconds;
        }
        
        /**
         * Converte i secondi totali nel formato "mm:ss.d".
         * Mantenuta per il calcolo del tempo totale di allenamento se necessario.
         * @param {number} totalSeconds - Secondi totali.
         * @returns {string} Stringa nel formato "mm:ss.d".
         */
        function secondsToTimeFormat(totalSeconds) {
            if (isNaN(totalSeconds) || totalSeconds <= 0) return "00:00.0";
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${seconds.toFixed(1).padStart(4, '0')}`;
        }


        async function fetchAllAthleteRecords() {
            // Leggiamo solo per poter associare l'ID Atleta a Nome/Cognome
            const snapshot = await firestore.collection('atleti').get();
            
            // LOG DELLE LETTURE ATLETI
            const readsCount = snapshot.docs.length;
            
            snapshot.forEach(doc => {
                athleteRecords.set(doc.id, doc.data());
            });
        }

        /**
         * Elabora i dati dell'allenamento. 
         * NON CALCOLA pi√π l'EP, ma recupera il valore esistente dal database (workout.ep).
         * Calcola i totali (tempo/distanza) per la visualizzazione.
         * @param {object} workout - Dati dell'allenamento.
         * @param {Map} records - Mappa dei record atleti (usata solo per nome/cognome).
         * @returns {object} Allenamento elaborato.
         */
        function calculateWorkoutData(workout, records) {
            if (!Array.isArray(workout.intervalli)) {
                console.warn('Dati intervalli mancanti o corrotti per l\'allenamento:', workout.id);
                return { ...workout, ep: 'N/A', distanzaTotale: null, tempoTotale: null, epMessage: 'Dati intervalli corrotti' };
            }

            const athleteData = records.get(workout.atletaId);
            let distanzaTotale = null;
            let tempoTotale = null;
            let epValue = workout.ep || null; // Utilizza il valore EP numerico gi√† nel DB

            const epDisplay = (epValue !== null) ? `${epValue.toFixed(2)}%` : 'N/A';
            const epMessage = (epValue === null || epValue === 0) ? 'EP non disponibile' : null;

            // Calcolo Totali per la visualizzazione
            const numberOfIntervals = workout.intervalli.length;
            if (workout.modalita === 'tempo') {
                // Calcolo Distanza Totale (sum degli intervalli)
                const totalMeters = workout.intervalli.map(i => parseFloat(String(i).replace(',', '.'))).filter(n => !isNaN(n)).reduce((a, b) => a + b, 0);
                distanzaTotale = `${totalMeters.toLocaleString('it-IT')}m`;
                
                // Calcolo Tempo Totale (durata * numero intervalli)
                const durationMinutes = parseInt(workout.tempo, 10);
                if (!isNaN(durationMinutes) && numberOfIntervals > 0) {
                    const totalMinutes = durationMinutes * numberOfIntervals;
                    const hours = Math.floor(totalMinutes / 60);
                    const minutes = totalMinutes % 60;
                    let timeString = '';
                    if (hours > 0) timeString += `${hours} ${hours > 1 ? 'ore' : 'ora'}`;
                    if (minutes > 0) {
                        if (hours > 0) timeString += ' e ';
                        timeString += `${minutes} minuti`;
                    }
                    tempoTotale = timeString || null;
                }

            } else if (workout.modalita === 'distanza') {
                // Calcolo Tempo Totale (sum dei tempi intervalli in secondi)
                const totalSeconds = workout.intervalli.map(timeToSeconds).reduce((a, b) => a + b, 0);
                tempoTotale = secondsToTimeFormat(totalSeconds);
                
                // Calcolo Distanza Totale (distanza * numero intervalli)
                const distanzaSelezionata = parseInt(workout.distanza, 10);
                if (!isNaN(distanzaSelezionata) && numberOfIntervals > 0) {
                    distanzaTotale = `${(distanzaSelezionata * numberOfIntervals).toLocaleString('it-IT')}m`;
                }
            }
            
            // Restituisce i dati elaborati
            return { 
                ...workout, 
                ep: epDisplay, // EP formattato per il display
                epValue: epValue, // EP numerico per l'ordinamento
                distanzaTotale, 
                tempoTotale, 
                epMessage 
            };
        }
        
        // --- LOGICA DI CARICAMENTO E RENDER OTTIMIZZATA ---

        async function loadAndProcessWorkouts() {
            loaderOverlay.classList.remove('hidden');
            
            const startDate = startDateInput.value;
            const endDate = endDateInput.value;

            // 1. Validazione delle date
            if (!startDate || !endDate) {
                resultsContainer.innerHTML = `<p class="text-center text-yellow-400 py-8 text-xl font-medium">Seleziona un intervallo di date valido.</p>`;
                loaderOverlay.classList.add('hidden');
                return;
            }

            const endDateObject = new Date(endDate);
            if (new Date(startDate) > endDateObject) {
                 resultsContainer.innerHTML = `<p class="text-center text-red-400 py-8 text-xl font-medium">La data di inizio non pu√≤ essere successiva alla data di fine.</p>`;
                loaderOverlay.classList.add('hidden');
                return;
            }


            try {
                // 2. Query ottimale per gli allenamenti (Lettura #1)
                let query = firestore.collection('allenamenti')
                    .where('tipo', '==', 'BIKE')
                    .where('data', '>=', startDate) 
                    .where('data', '<=', endDate)   
                    .orderBy('data', 'asc');       

                const snapshot = await query.get();
                
                const readsAllenamenti = snapshot.docs.length;


                // 3. CONTROLLO CONDIZIONALE PER EVITARE LA LETTURA DEGLI ATLETI
                if (readsAllenamenti === 0) {
                    resultsContainer.innerHTML = `<p class="text-center text-slate-400 py-8 text-xl">Nessun allenamento Bike trovato per l'intervallo selezionato.</p>`;
                    loaderOverlay.classList.add('hidden');
                    return; // Interrompe il processo qui
                }
                
                // 4. Caricamento record atleti (Lettura #2) - Mantenuto per nome/cognome
                await fetchAllAthleteRecords();


                // 5. Elaborazione e preparazione dei dati (SENZA AGGIORNAMENTO EP NEL DB)
                const workouts = [];

                snapshot.docs.forEach(doc => {
                    try {
                        const data = doc.data();
                        if (!data.data || !data.intervalli || !data.atletaId) {
                            console.warn("Documento scartato per dati mancanti (data, intervalli, o atletaId):", doc.id);
                            return; // Salta questo documento
                        }
                        
                        // Elabora i dati dell'allenamento (formattazione totali e recupero EP esistente)
                        const processedWorkout = calculateWorkoutData({ id: doc.id, ...data }, athleteRecords);
                        
                        // Aggiungi l'allenamento elaborato alla lista
                        workouts.push(processedWorkout);

                    } catch (e) {
                        console.error("Errore nell'elaborazione del documento:", doc.id, e);
                    }
                });

                // 6. Raggruppamento e ordinamento (eseguito lato client)
                const groupedByDate = workouts.reduce((acc, workout) => {
                    const date = workout.data;
                    const groupKey = workout.modalita === 'distanza' ? `${workout.distanza}m` : `${workout.tempo}min`;
                    
                    if (!acc[date]) acc[date] = {};
                    if (!acc[date][groupKey]) acc[date][groupKey] = [];
                    
                    acc[date][groupKey].push(workout);
                    return acc;
                }, {});

                for (const date in groupedByDate) {
                    for (const group in groupedByDate[date]) {
                        groupedByDate[date][group].sort((a, b) => {
                            // Usiamo l'epValue numerico esistente per l'ordinamento (null va alla fine)
                            const epA = a.epValue || 0; 
                            const epB = b.epValue || 0;
                            return epB - epA;
                        });
                    }
                }
                
                renderRanking(groupedByDate);

            } catch (error) {
                console.error("Errore nel caricamento: ", error);
                
                // Messaggio che guida l'utente a creare l'indice necessario
                resultsContainer.innerHTML = `<div class="p-8 bg-red-900/40 border-2 border-red-700 rounded-xl text-red-200 shadow-xl">
                    <p class="font-bold text-2xl mb-3">‚ö†Ô∏è ERRORE: INDICE MANCANTE</p>
                    <p class="text-lg">La query ottimizzata che hai tentato di eseguire richiede un **indice composto** di Cloud Firestore. </p>
                    <p class="mt-4 text-lg">L'indice necessario √®: <code>allenamenti</code> > <code>tipo</code> (Asc), <code>data</code> (Asc). Crealo sulla console Firebase.</p>
                </div>`;
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }

        function renderRanking(groupedWorkouts) {
            resultsContainer.innerHTML = '';
            // L'ordinamento qui garantisce che le date siano visualizzate dal pi√π recente al pi√π vecchio
            const sortedDates = Object.keys(groupedWorkouts).sort((a, b) => new Date(b) - new Date(a));

            if (sortedDates.length === 0) {
                resultsContainer.innerHTML = `<p class="text-center text-slate-400 py-8 text-xl">Nessun allenamento Bike trovato per l'intervallo selezionato.</p>`;
                return;
            }

            sortedDates.forEach(date => {
                const workoutsByGroup = groupedWorkouts[date];
                const formattedDate = new Date(date).toLocaleDateString('it-IT', { weekday: 'long', day: '2-digit', month: 'long', year: 'numeric' });
                
                const dayContainer = document.createElement('div');
                dayContainer.className = 'bg-slate-900/80 border border-slate-700/60 rounded-xl shadow-2xl p-6';
                dayContainer.innerHTML = `<h2 class="text-3xl font-extrabold text-white mb-6 pb-4 border-b-2 border-slate-700">${formattedDate}</h2>`;
                
                const dayContent = document.createElement('div');
                dayContent.className = 'space-y-8';

                const sortedGroups = Object.keys(workoutsByGroup).sort();

                sortedGroups.forEach(groupKey => {
                    const workoutsForGroup = workoutsByGroup[groupKey];
                    const groupContainer = document.createElement('div');
                    
                    const groupTitle = document.createElement('h3');
                    groupTitle.className = 'text-2xl font-bold text-sky-400 mb-4 border-l-4 border-sky-400 pl-3';
                    groupTitle.textContent = `Classifica su ${groupKey}`;
                    groupContainer.appendChild(groupTitle);

                    const rankingList = document.createElement('div');
                    rankingList.className = 'space-y-4';

                    workoutsForGroup.forEach((workout, index) => {
                        const card = document.createElement('div');
                        card.className = 'ranking-card p-4 md:p-6 rounded-lg shadow-md';

                        let epOrMessageBadge;
                        if (workout.epMessage) {
                            epOrMessageBadge = `<span class="text-sm font-semibold bg-red-600/30 text-red-300 px-3 py-1 rounded-full whitespace-nowrap">${workout.epMessage}</span>`;
                        } else if (workout.ep && workout.ep !== 'N/A') {
                            epOrMessageBadge = `<span class="text-lg font-extrabold bg-amber-600/30 text-amber-300 px-3 py-1 rounded-full whitespace-nowrap">${workout.ep} EP</span>`;
                        } else {
                            epOrMessageBadge = '';
                        }
                        
                        let rankClass = 'text-slate-600';
                        if (index === 0) rankClass = 'text-amber-400 drop-shadow-[0_0_5px_rgba(251,191,36,0.6)]';
                        if (index === 1) rankClass = 'text-gray-300';
                        if (index === 2) rankClass = 'text-amber-700';
                        const rankIndicator = `<span class="text-4xl font-black ${rankClass} w-16 md:w-20 text-center leading-none">${index + 1}¬∞</span>`;

                        const cardHeader = `
                            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 pb-2 border-b border-slate-700/50">
                                <div class="flex items-center gap-4">
                                    ${rankIndicator}
                                    <h4 class="text-3xl font-extrabold text-white tracking-tight">${workout.cognomeAtleta}</h4>
                                </div>
                                ${epOrMessageBadge}
                            </div>`;
                        
                        let totalInfo = '';
                        const infoClass = "text-md text-slate-300";
                        const strongClass = "font-semibold text-slate-400 mr-2";

                        if (workout.distanzaTotale) {
                            totalInfo += `<p class="${infoClass}"><strong class="${strongClass}">Distanza Totale:</strong> <span class="text-lg font-bold text-sky-300">${workout.distanzaTotale}</span></p>`;
                        }
                        if (workout.tempoTotale) {
                            totalInfo += `<p class="${infoClass} mt-1"><strong class="${strongClass}">Tempo Totale:</strong> <span class="text-lg font-bold text-sky-300">${workout.tempoTotale}</span></p>`;
                        }

                        const intervalsList = (workout.intervalli || []).map((interval, i) => `<li class="bg-slate-700 hover:bg-slate-600 rounded-md px-3 py-1.5 transition-colors"><strong class="text-slate-500">#${i + 1}:</strong> ${interval}</li>`).join('');
                        
                        const cardBody = `
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 pl-16">
                                <div class="md:col-span-1 space-y-2">${totalInfo}</div>
                                <div class="md:col-span-2">
                                    <h5 class="font-bold text-slate-300 mb-2">Intervalli (${(workout.intervalli || []).length} x ${groupKey})</h5>
                                    <ul class="flex flex-wrap gap-3 text-sm font-mono text-white">
                                        ${intervalsList}
                                    </ul>
                                </div>
                            </div>`;
                        
                        card.innerHTML = cardHeader + cardBody;
                        rankingList.appendChild(card);
                    });
                    groupContainer.appendChild(rankingList);
                    dayContent.appendChild(groupContainer);
                });

                dayContainer.appendChild(dayContent);
                resultsContainer.appendChild(dayContainer);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            const today = getTodayDateString();
            startDateInput.value = today;
            endDateInput.value = today;
            
            filterBtn.addEventListener('click', loadAndProcessWorkouts);
            
            // Carica i dati del giorno corrente all'avvio
            loadAndProcessWorkouts();
        });
    </script>
</body>
</html>